
\section{Описание формата представления расчетной задачи}

\subsection{Введение}

В ходе работы над графическим интерфейсом к программе Fdtd3d, неоднократно
рассматриваемой нами в предыдущих работах, остро возникла необходимость
в создании (и стандартизации) некоторого формата файлов, который мог бы
использоваться для обмена данными между программой-редактором и программой,
непосредственно выполняющей численное моделирование задачи, сформулированной
пользователем в интерактивном режиме. Данные, в передаче которых возникла
необходимость, включают в себя информацию~о:
\begin{itemize}
\item дискретизации счетных пространства и времени;
\item используемых на границах счетного объема граничных условиях;
\item области TFSF;
\item области вычисления интеграла Кирхгофа для расчета полей в дальней зоне;
\item свойствах используемых в задаче материалах;
\item распределении этих материалов в дискретном пространстве;
\item расположении в счетном объеме пробников;
\item расположении в счетном объеме сосредоточенных элементов.
\end{itemize}

Помимо перечисленных данных приветствуется поддержка форматом дополнительной
информации определенного рода (метаданных), такой как:
\begin{itemize}
\item номер версии формата, с помощью которого был создан файл;
\item название и версия приложения, записавшего файл;
\item дата и время создания файла;
\item дата и время последней модификации файла;
\item имя пользователя, создавшего данный файл;
\item название организации, имеющей отношение к информации, записанной в файле.
\end{itemize}
Более подробно назначение каждого поля будет расписано в пункте работы,
посвященном детальному описанию структуры формата.

К формату данных предъявлялся следующий список требований:
\begin{itemize}
\item поддержка больших объёмов данных (как минимум порядка нескольких
      гигабайт);
\item высокая производительность операций чтения и записи;
\item расширяемость формата с сохранением совместимости;
\item возможность использования в параллельных программах (в перспективе);
\item возможность поточной передачи данных по сети (в перспективе);
\item поддержка прозрачного механизма компрессии/декомпрессии данных «на лету»
      (в перспективе).
\end{itemize}

Так как обеспечить выполнение всех этих требований представляется работой
в высшей степени нетривиальной и трудоемкой, было решено отказаться от попыток
создания собственного формата данных «с нуля», а вместо этого найти готовое
решение, по возможности --- распространяемое на условиях какой-либо свободной
лицензии. Такое решение было найдено и о нем пойдет речь в следующей части
работы.


\subsection{О формате HDF~5}

Аббревиатура HDF расшифровывается как Hierarchical Data Format~\cite{bib:Hdf5WikipediaArticle}, что можно
перевести на русский язык как <<иерархический формат данных>>. Цифра~<<5>>
относится к версии формата --- пятой, на данный момент последней и наиболее
совершенной в технологическом плане (однако по-прежнему поддерживается
предыдущая версия формата --- HDF~4, т.~к. файлы, записанные в этом формате,
все еще используются в работе некоторых организаций). Первые версии формата
были разработаны Национальным центром по применению
суперкомпьютеров~\cite{bib:NcsaWebsite} (университет штата Иллинойс, США) в конце
1980-x годов, в 2004~г. была основана некоммерческая организация HDF~Group~\cite{bib:HdfGroupWebsite},
призванная координировать развитие формата. В настоящее время этой организацией
разработана библиотека для встраивания поддержки формата в пользовательские
приложения, а также набор прикладных программ для работы с файлами форматов
HDF~4/HDF~5.

HDF~Group официально поддерживает API к библиотеке HDF~5 для следующих языков
программирования: C, C++, Fortran~77/90, Java. Кроме того, существуют сторонние
проекты, адаптирующие библиотеку для использования в программах на: Perl,
Python, GDL, IDL, языках математических пакетов MATLAB, Scilab и Mathematica.
Формат широко используется многими компаниями в исследовательской работе
в различных областях науки, для примера достаточно упомянуть такие известные
организации, как NASA и Intel. Более полный список проектов, использующих HDF~5,
можно найти по адресу~[3]
Однако, вернемся к списку требований, перечисленных в первом разделе. В ходе
исследования официальной документации было выяснено, что формат HDF~5
удовлетворят всем этим требованиями. А именно:
\begin{itemize}
\item
поддерживаются очень большие объемы данных, в отличие от четвертой версии
формата, где размер файла был ограничен \valu{2}{ГБ} из-за использования
32-битных знаковых целых чисел для адресации;

\item
иерархичность формата и использование символьных имен позволяет добиться
совместимости между версиями как в прямом, так и в обратном направлении;

\item
имеется встроенная поддержка параллельных программ, написанных с использованием
MPI, использующая функции MPI~I/O из MPI~2;

\item
поддерживается работа с сетевыми потоками;

\item
имеется возможность прозрачного сжатия данных про помощи т.~н. \emph{фильтров}.
\end{itemize}

Также отметим, что используемая HDF лицензия является свободной
и не ограничивает распространение и использование (в том числе коммерческое)
ни оригинальных, ни модифицированных исходных кодов библиотеки при условии
сохранения упоминания оригинальных авторов и явного указания на факт модификации
исходного кода. С полным текстом оригинальной лицензии на английском языке можно
ознакомиться на сайте HDF~Group~\cite{bib:HdfGroupWebsite}.


\subsection{Базовые понятия HDF~5}

Рассмотрим основные понятия, с которыми мы неизбежно сталкиваемся при работе
с файлами в формате HDF5. Это типы данных, пространства данных, наборы данных
и группы. Ниже мы объясним их назначение (в скобках приведено оригинальное
англоязычное название, используемое в документации проекта HDF).

\emph{Тип данных} (\emph{datatype}) определяет формат единичного элемента
данных некоторого вида. Типы данных могут быть как \emph{элементарными}
(\emph{atomic}), представленные, например, целыми числами и числами с плавающей
запятой, единичными символами и строками символов, так и \emph{составными}
(\emph{compound}), включающими в себя данные разных типов.

\emph{Пространство данных} (\emph{dataspace}) определяет способ организации
множества однотипных элементов, не зависящий от конкретного типа. Согласно
документации, пространства могут быть \emph{простыми} (\emph{simple})
и \emph{сложными} (\emph{complex}), однако реализация сложных пространств данных
оставлена для будущих версий формата. Простые пространства данных представляют
собой массивы элементов произвольной размерности. Также к ним относится
специальный случай скалярного пространства данных, представляющий собой
единственный элемент.

\emph{Набор данных} (\emph{dataset}) --- это множество данных определенного
типа, организованных в соответствии с некоторым пространством. Наборы данных
хранятся в HDF-файле, имеют собственное имя и принадлежат некоторой группе.

\emph{Группы} (\emph{group}) предназначены для создания иерархии внутри файла.
Группы имеют имена и включают в себя наборы данных и другие группы. Иерархия
групп начинается с т.~н. корневой группы, обозначающейся символом <</>>.
Полный путь к группе или набору данных последовательно перечисляет имена
родительских групп, разделенных тем символом прямого слеша, по аналогии
с файловыми путями в POSIX-системах. Аналогия с файловой системой укрепляется
еще и тем, что для доступа к группе или набору можно использовать как полные,
так и относительные пути.

Библиотека HDF предоставляет программисту возможность работать на описанном выше
уровне абстракции, оперируя группами и наборами данных, а не последовательностью
байт, составляющих файл.


\subsection{Создание производного формата}

Как ясно из предыдущего раздела, формат HDF представляет только весьма общие
средства хранения данных, оставляя конкретную структуру групп и наборов данных
на откуп конечным пользователям. Следовательно, нам необходимо разработать
иерархическую структуру, подходящую для нашей задачи. Начнем с определения
используемых типов данных.


\subsubsection{Типы данных}

Прежде всего, нам потребуется сохранять в файл большие массивы отчетов в формате
вещественных чисел с плавающей запятой. В зависимости от конкретной реализации
точность таких чисел может быть как двойной (тип \code{double} в С++), так и
одинарной (тип \code{float}). Ниже будем обозначать такие числа как \code{real}.
Помимо вещественных чисел необходимо сохранять целые числа (как минимум
32-разрядные со знаком), будем обозначать их как \code{integer}. Также для
описания задачи необходимы строковые значения, причем будем различать
ASCII-строки (допускающие использование только символов нижней половины кодовой
таблицы) и Unicode-строки (позволяющие хранить текст на практически любом
существующем языке)\footnote{
    Формат HDF5 не имеет явной поддержки широких строк, однако позволяет
    хранить в обычных строках данные, закодированные в любой кодировке.
    Поэтому для представления текстов с не-латинскими символами используются
    обычные строки, кодированные в UTF-8~\cite{bib:Utf8WikipediaArticle} ---
    кодировку с переменной длиной представления символов.}.

% -- Таблица.
\begin{table}[tb]
\caption{Используемые типы данных.}
\label{tab:Hdf5FileFormat:DataTypes}

\begin{tabularx}{\textwidth}{|l|l|l|}
\hline
Обозначение           & Тип в языке C++ & Формат хранения библиотеки HDF~5 \\
\hline
\code{integer}        & \code{int}          & \code{H5T_STD_I32BE} \\
\code{real}           & \code{float}        & \code{H5T_IEEE_F32BE} \\
\code{real}           & \code{double}       & \code{H5T_IEEE_F64BE} \\
\code{string}         & \code{std::string}  & \code{H5T_C_S1} \\
\code{unicode string} & \code{std::wstring} & \code{H5T_C_S1}\\
\hline
\end{tabularx}
\end{table}


\subsubsection{Корневая группа файла}

В корне файла должны находиться две подгруппы: \code{metadata} и \code{scene}.
Первая содержит информацию о файле и его создателе, вторая содержит фактические
данные, необходимые для решения задачи моделирования. Структура этих групп
подробно описывается в следующих подразделах.


\subsubsection{Группа метаданных}

Метаданные --- это вспомогательная информация, которая непосредственно
не используется в процессе расчетов. В нашем случае это:

\noindent
\begin{tabularx}{\textwidth}{l|ll}
\code{Metadata} =
    & \code{FileFormatVersion}  & : \code{integer} \\
    & \code{ApplicationName}    & : \code{unicode string} \\
    & \code{AuthorName}         & : \code{unicode string} \\
    & \code{AuthorOrganization} & : \code{unicode string} \\
    & \code{CreationTime}       & : \code{universal timestamp} \\
    & \code{ModificationTime}   & : \code{universal timestamp}
\end{tabularx}

\noindent
Рассмотрим теперь назначение каждого из перечисленных полей более подробно:

\code{FileFormatVersion} --- версия формата файла, используется для проверки на
совместимость формата с программным обеспечением. Программа не должна пытаться
обрабатывать файл, версия формата которой превышает наивысшую версию формата,
поддерживаемого программой.

\code{АpplicationName} --- название (и версия) программы, которая сгенерировала
данный файл. Значение этого поля может измениться после пересохранения файла
в другой программе.

\code{AuthorName} --- имя человека, создавшего файл. Это поле нужно для
информирования о владельце авторских прав на файл и должно копироваться
при пересохранении.

\code{AuthorOrganization} --- организация, к которой относит себя человек,
создавший файл. Тоже выступает некоторого рода индикатором авторских прав. Так,
например, если файл создан в рамках научной работы в университете, данное поле
может содержать название университета. Это поле также должно копироваться при
пересохранении.

\code{СreationTime} --- время создания файла с точностью до секунд по
Всемирному координированному времени (UTC). Это поле не должно изменять свое
значение при пересохранении.

\code{ModificationTime} --- время последней модификации файла с точностью до
секунд по UTC. В отличие от предыдущего, должно обновляться при каждой
модификации файла. Сразу после создания файла значение равно значению параметра
\code{CreationTime}\footnote{
    Несмотря на то, что современные файловые системы хранят время создания
    и/или модификации файлов, может оказаться, что они будут потеряны в ходе
    файловых операций. Поэтому оказывается целесообразно продублировать их
    в содержимом файла.}.


\subsubsection{Группа Scene}

Теперь рассмотрим собственно данные, хранить которые призван файл описываемого
формата. Они хранятся в группе \code{scene} в следующем формате:

\noindent
\begin{tabularx}{\textwidth}{l|ll}
\code{Scene} =
    & \code{Axes}       & : \code{Axis[3]} \\
    & \code{Boundaries} & : \code{Boundary[6]} \\
    & \code{Tfsf}       & : \code{TfsfRegion} \\
    & \code{Ff}         & : \code{FfRegion} \\
    & \code{Materials}  & : \code{Material[]} \\
    & \code{Probes}     & : \code{Probe[]} \\
    & \code{Lumpeds}    & : \code{LumpedElement[]} \\
    & \code{Structure}  & : \code{Structure}
\end{tabularx}

\code{Axes} --- cписок из трех элементов, каждый из которых описывает параметры
дискретизации по одной из осей в трехмерном пространстве:
\begin{itemize}
\item \code{axes[0]} --- ось~$x$ (абсцисс);
\item \code{axes[1]} --- ось~$y$ (ординат);
\item \code{axes[2]} --- ось~$z$ (аппликат).
\end{itemize}
При этом дискретизация по конкретной оси может быть как равномерной, так
и неравномерной. Подробное описание структуры \code{Axis} дано ниже
в соответствующем подразделе.

\code{Boundaries} --- cписок из шести элементов, описывающих параметры
граничного условия на гранях счетного объёма в форме прямоугольного
параллелепипеда. Соответствие элементами списка и гранями следующее:
\begin{itemize}
\item \code{boundaries[0]} --- нижняя из граней, перпендикулярных оси~$x$;
\item \code{boundaries[1]} --- верхняя из граней, перпендикулярных оси~$x$;
\item \code{boundaries[2]} --- нижняя из граней, перпендикулярных оси~$y$;
\item \code{boundaries[3]} --- верхняя из граней, перпендикулярных оси~$y$;
\item \code{boundaries[4]} --- нижняя из граней, перпендикулярных оси~$z$;
\item \code{boundaries[5]} --- верхняя из граней, перпендикулярных оси~$z$.
\end{itemize}
Граничное условие может быть различных типов, но в первую очередь должны быть
реализованы граничные условия типа PML. Также нужно учитывать, что не все
возможные комбинации граничных условий осуществимы на практике. Подробное
описание структуры \code{Boundary} приведено ниже в соответствующем подразделе.

\code{Materials} --- список произвольной длины, хранящий описание материалов,
использованных в структуре. Индекс материала в массиве используется как его
идентификатор, поэтому порядок материалов важен. Материал может быть как
диэлектриком, так и проводником, возможно даже идеально проводящим материалом.
Материал, находящийся под индексом 0, считается материалом окружающей среды.
Подробное описание структуры \code{Material} приведено ниже в соответствующем
подразделе.

\code{Probes} --- список произвольной длины, хранящий пробники, значения
с которых нужно снять в процессе моделирования. Пробники могут быть как
точечными, так и иметь протяженность в пространстве. Подробное описание
структуры \code{Probe} приведено ниже в соответствующем подразделе.

\code{Lumpeds} --- список произвольной длины, хранящий данные о размещённых
на сцене сосредоточенных элементах. Подробное описание структуры \code{Lumped},
характеризающей тип и параметры сосредоточенного элемента, дано ниже
в соответствующем позразделе.

\code{Structure} --- описание распределения всех материалов внутри счетного
объёма. Подробное описание структуры \code{Structure} последует ниже
в соответствующем подразделе.


\subsubsection{Группа Axis}

\noindent
\begin{tabularx}{\textwidth}{l|ll}
\code{Axis} =
    & \code{Type}    & : \code{string} \\
    & \code{Minimum} & : \code{real} \\
    & \code{Maximum} & : \code{real} \\
    & \code{Count}   & : \code{integer} \\
    & \multicolumn{2}{l}{В случае равномерной сетки:} \\
    & \code{Delta}   & : \code{real} \\
    & \multicolumn{2}{l}{В случае неравномерной сетки:} \\
    & \code{Subdivs} & : \code{real[Count]}
\end{tabularx}

\code{Type} --- строка, определяющая тип дискретизирующей решетки вдоль данной
оси. Разбиение может быть равномерным (эквидистантным) либо неравномерным
(неэквидистантным). Допустимые значения данного поля:
\begin{itemize}
\item \code{"regular"} --- используется равномерная решетка;
\item \code{"irregular"} --- используется неравномерная решетка.
\end{itemize}
Все иные значения должны интерпретироваться как ошибочные.

\code{Minimum} --- нижняя граница счетного объёма вдоль данной оси.
\code{Maximum} --- верхняя граница счетного объёма вдоль данной оси.
\code{Count} --- точное число подразбиений оси.
\code{Subdivs} --- координаты узлов неравномерной сетки в проекции на данную ось.


\subsubsection{Группа Boundary}

\noindent
\begin{tabularx}{\textwidth}{l|ll}
\code{Boundary} =
    & \code{Type}  & : \code{string} \\
    & \code{Order} & : \code{integer} \\
    & \multicolumn{2}{l}{Параметры конкретного граничного условия:} \\
    & \multicolumn{2}{l}{\dots}
\end{tabularx}

\code{Type} --- строка, определяющая тип граничного условия, выполняющегося
на данной грани. Может быть использовано одно из следующих значений:
\begin{itemize}
\item \code{"pec"} --- нет поглощающего граничного условия;
\item \code{"berenger-pml"} --- используются система идеально согласованных
      слоев (PML) Беренже.
\end{itemize}
В дальнейшем планируется добавить новые типы граничных условий, однако, на
данный момент все другие значения должны считаться ошибочными.

\code{Order} --- порядок граничного условия. Трактовка этого параметра зависит
от типа используемого граничного условия, но в общем случае он обозначает число
дополнительных слоев поглощения, создаваемых на границе счетного объема.


\subsubsection{Группа Material}

\noindent
\begin{tabularx}{\textwidth}{l|ll}
\code{Material} =
    & \code{Name} & : \code{string} \\
    & \code{Type} & : \code{string} \\
    & \multicolumn{2}{l}{Для линейных изотропных материалов:} \\
    & \code{Epsilon} & : \code{real} \\
    & \code{Mu}      & : \code{real} \\
    & \code{SigmaE}  & : \code{real} \\
    & \code{SigmaH}  & : \code{real}
\end{tabularx}

\code{Name} --- название материала. Имя должно подчиняться правилам именования
идентификаторов в языках программирования высокого уровня (ЯВУ) и не должно
использовать символы национальных алфавитов. Кроме того оно не должно совпадать
с именами других материалов в этом же файле. Эти ограничения вводятся для того,
чтобы надежным способом адресовать материалы в пользовательских скриптах
и расширениях.

\code{Type} --- строка, определяющая тип материала. На данный момент материалы
могут быть двух типов: идеальный проводник и линейный изотропный материал
с конечной проводимостью:
\begin{itemize}
\item \code{"pec"} --- идеальный проводник (PEC);
\item \code{"linear-isotropic"} --- линейный изотропный материал.
\end{itemize}
Возможно, в будущем появятся и другие значения, но в данной версии формата все
иные значения данного поля должны интерпретироваться как ошибочные.


\subsubsection{Группа Probe}

\noindent
\begin{tabularx}{\textwidth}{l|ll}
\code{Probe} =
    & \code{Name}              & : \code{string} \\
    & \code{Type}              & : \code{string} \\
    & \code{Xmin}, \code{Xmax} & : \code{integer} \\
    & \code{Ymin}, \code{Ymax} & : \code{integer} \\
    & \code{Zmin}, \code{Zmax} & : \code{integer}
\end{tabularx}

\code{Name} --- имя пробника, должно подчиняться требованиям, накладываемым
на имена переменных в ЯВУ и не должно совпадать с именами других пробников
в файле.

\code{Type} --- определяет тип физической величины, регистрируемой пробником
в заданной области пространства.

\code{Xmin}, \code{Xmax}, \code{Ymin}, \code{Ymax}, \code{Zmin}, \code{Zmax} ---
координаты вершин прямоугольного параллелепипеда, за которой наблюдает пробник.
Трехмерная область может для некоторых типов пробников вырождаться в двумерную,
одномерную, либо даже в точку.


\subsubsection{Группа Lumped}

\noindent
\begin{tabularx}{\textwidth}{l|ll}
\code{Lumped} =
    & \code{Name}                  & : \code{string} \\
    & \code{Type}                  & : \code{string} \\
    & \code{X}, \code{Y}, \code{Z} & : \code{integer} \\
    & \code{Orientation}           & : \code{integer} \\
    & \multicolumn{2}{l}{Параметры конкретного элемента:} \\
    & \multicolumn{2}{l}{\dots} \\
\end{tabularx}

\code{Name} --- имя сосредоточенного элемента. Должно быть правильным
идентификатором ЯВУ и не должно пересекаться с именами других сосредоточенных
элементов в том же самом файле.

\code{Type} --- тип элемента.

\code{X}, \code{Y}, \code{Z} --- координаты ячейки, в которой размещен
сосредоточенный элемент.

\code{Orientation} --- пространственная ориентация сосредоточенного элемента
в указанной ячейке. Значения задается по правилам, аналогичным рассмотренным
выше для списка \code{Boundaries}.


\subsubsection{Группа Structure}

\noindent
\begin{tabularx}{\textwidth}{l|ll}
\code{Structure} =
    & \code{Xdata} : \code{byte[][][]} \\
    & \code{Ydata} : \code{byte[][][]} \\
    & \code{Zdata} : \code{byte[][][]} \\
\end{tabularx}

\code{Xdata}, \code{Ydata}, \code{Zdata} --- трехмерные массивы, содержащие
индексы материалов, используемых в ребрах ячеек Йе конкретных ячеек счетного
объема. Размерности этих массивов совпадают и задаются значениями параметров
\code{Count} в описании осей счетного пространства.
